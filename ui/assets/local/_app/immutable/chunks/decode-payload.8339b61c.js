import{t as C}from"./translate.c28e5b4f.js";import{s as W,b as S}from"./data-encoder-config.3c4a34eb.js";import{h as f,i as x}from"./has.0120f47d.js";import{v as q,a as k}from"./is-http.f1b57c32.js";import{s as w,p as O}from"./parse-with-big-int.0036a80a.js";async function B({payloads:e,namespace:c,settings:o,accessToken:r,encode:d=!1}){var l,P,j;const n=(l=o==null?void 0:o.codec)==null?void 0:l.endpoint,s=(P=o==null?void 0:o.codec)==null?void 0:P.passAccessToken,t=(j=o==null?void 0:o.codec)==null?void 0:j.includeCredentials,i={"Content-Type":"application/json","X-Namespace":c};if(s)if(q(n))i.Authorization=`Bearer ${r}`;else return W(),e;const m=t?{headers:i,credentials:"include",method:"POST",body:w(e)}:{headers:i,method:"POST",body:w(e)};return fetch(n+(d?"/encode":"/decode"),m).then(a=>{if(f(a,"ok")&&!a.ok)throw{statusCode:a.status,statusText:a.statusText,response:a,message:d?C("common.encode-failed"):C("common.decode-failed")};return a.json()}).then(a=>(S(),a)).catch(a=>(W(a),e))}const E=e=>Array.isArray(e)?e:[e];function h(e,c=!0){var r;if(e===null)return e;const o=k(String(((r=e==null?void 0:e.metadata)==null?void 0:r.encoding)??""));if(e!=null&&e.metadata&&(e.metadata.encodingDecoded=o),o!=null&&o.startsWith("json/"))try{const d=O(k(String((e==null?void 0:e.data)??"")));return c?d:{...e,data:d}}catch(d){console.warn("Could not parse payload: ",d)}return o==="binary/null"?c?null:{...e,data:null}:e}const N=(e,c=!0)=>{if(f(e,"searchAttributes")&&f(e.searchAttributes,"indexedFields")){const o=e.searchAttributes.indexedFields;Object.entries(o).forEach(([r,d])=>{o[r]=h(d,c)})}if(f(e,"memo")&&f(e.memo,"fields")){const o=e.memo.fields;Object.entries(o).forEach(([r,d])=>{o[r]=h(d,c)})}if(f(e,"header")&&f(e.header,"fields")){const o=e.header.fields;Object.entries(o).forEach(([r,d])=>{o[r]=h(d,c)})}if(f(e,"queryResult")){const o=e==null?void 0:e.queryResult;Object.entries(o).forEach(([r,d])=>{o[r]=h(d,c)})}return e},T=(e,c,o)=>async(r,d=!0)=>{var n;if((n=c==null?void 0:c.codec)!=null&&n.endpoint){const s=await B({payloads:{payloads:r},namespace:e,settings:c,accessToken:o});return((s==null?void 0:s.payloads)??[]).map(t=>h(t,d))}else return r.map(s=>h(s,d))},u=(e,...c)=>{for(const o of c)if(e===o)return!0;return!1},R=async(e,c,o,r)=>{const d=T(c,o,r);if(e)for(const n of Object.keys(e))if(u(n,"payloads","encodedAttributes")&&e[n]){const s=E(e[n]),t=await d(s);e[n]=u(n,"encodedAttributes")?t[0]:t}else{const s=e[n];x(s)&&(e[n]=await R(s,c,o,r))}return e},F=async(e,c,o,r,d=!0)=>{if(!e)return e;const n=T(c,o,r),s={...e};if(e)for(const t of Object.keys(s))if(u(t,"payloads","encodedAttributes")&&s[t]){const i=E(s[t]),m=await n(i,d);s[t]=u(t,"encodedAttributes")?m[0]:m}else{const i=s[t];x(i)&&(s[t]=await F(i,c,o,r,d))}return s},X=async({attributes:e,namespace:c,settings:o,accessToken:r})=>await R(e,c,o,r);export{h as a,B as b,X as c,N as d,F as e};
