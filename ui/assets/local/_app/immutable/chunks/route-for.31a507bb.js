import{B as k,e as h,O as f}from"./encode-uri.d223350b.js";import{b as a}from"./paths.1b850ea8.js";class c extends Error{}c.prototype.name="InvalidTokenError";function F(e){return decodeURIComponent(atob(e).replace(/(.)/g,(t,r)=>{let o=r.charCodeAt(0).toString(16).toUpperCase();return o.length<2&&(o="0"+o),"%"+o}))}function I(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw new Error("base64 string is not of the correct length")}try{return F(t)}catch{return atob(t)}}function U(e,t){if(typeof e!="string")throw new c("Invalid token specified: must be a string");t||(t={});const r=t.header===!0?0:1,o=e.split(".")[r];if(typeof o!="string")throw new c(`Invalid token specified: missing part #${r+1}`);let s;try{s=I(o)}catch(n){throw new c(`Invalid token specified: invalid base64 for part #${r+1} (${n.message})`)}try{return JSON.parse(s)}catch(n){throw new c(`Invalid token specified: invalid json for part #${r+1} (${n.message})`)}}const m=(e,t)=>{const r=t instanceof URLSearchParams;return t&&!r&&(t=new URLSearchParams(t)),t?`${e}?${t}`:e},C=()=>`${a}/namespaces`,d=({namespace:e})=>`${a}/namespaces/${e}`,E=()=>`${a}/select-namespace`,g=e=>`${d(e)}/workflows`,R=({namespace:e,query:t,search:r,page:o})=>m(g({namespace:e}),{query:t,search:r,...o&&{page:o}}),O=e=>`${d(e)}/archival`,i=({workflow:e,run:t,...r})=>{const o=h(e);return`${g(r)}/${o}/${t}`},w=e=>`${d(e)}/schedules`,D=({namespace:e})=>`${w({namespace:e})}/create`,L=({scheduleId:e,namespace:t})=>{const r=h(e);return`${w({namespace:t})}/${r}`},W=({scheduleId:e,namespace:t})=>{const r=h(e);return`${w({namespace:t})}/${r}/edit`},N=({queryParams:e,...t})=>{const r=`${i(t)}/history`;return m(`${r}`,e)},_=({eventId:e,...t})=>{const r=`${i(t)}/history/events/${e}`;return m(`${r}`)},x=e=>`${i(e)}/workers`,A=e=>{const t=h(e.queue);return`${d({namespace:e.namespace})}/task-queues/${t}`},H=e=>`${i(e)}/stack-trace`,T=e=>`${i(e)}/query`,q=e=>`${i(e)}/pending-activities`,j=e=>{const{settings:t,searchParams:r,originUrl:o}=e;switch(t.auth.flow){case f.AuthorizationCode:default:return S(t,r,o);case f.Implicit:return v(t,r,o)}},S=(e,t,r)=>{const o=new URL(`${a}/auth/sso`,e.baseUrl);let s=e.auth.options??[];return s=[...s,"returnUrl"],s.forEach(n=>{if(!t)return;const u=t.get(n);u&&o.searchParams.set(n,u)}),!o.searchParams.get("returnUrl")&&r&&o.searchParams.set("returnUrl",r),o.toString()},v=(e,t,r)=>{const o=new URL(e.auth.authorizationUrl);o.searchParams.set("response_type","id_token"),o.searchParams.set("client_id",e.auth.clientId),o.searchParams.set("redirect_uri",r),o.searchParams.set("scope",e.auth.scopes.join(" "));const s=crypto.randomUUID();window.localStorage.setItem("nonce",s),o.searchParams.set("nonce",s);const n=crypto.randomUUID();return sessionStorage.setItem(n,t.get("returnUrl")??(r||"/")),o.searchParams.set("state",n),o.toString()};class l extends Error{}class y extends l{}class $ extends l{}const z=e=>{const t=new URLSearchParams(e.substring(1)),r=t.get("id_token");if(!r)return null;if(!window.localStorage.getItem("nonce"))throw new y("No nonce in localStorage");let s;try{s=U(r)}catch(p){throw p instanceof c?new l("Invalid id_token in hash"):new l(p)}const n=t.get("state");if(!n)throw new $("No state in hash");const u=sessionStorage.getItem(n);if(!u)throw new $("Hash state missing from sessionStorage");return{redirectUrl:u,authUser:{idToken:r,name:s.name,email:s.email},stateKey:n}},B=(e="",t=k)=>{if(t){const r=new URL(`${a}/login`,window.location.origin);return r.searchParams.set("returnUrl",window.location.href),e&&r.searchParams.set("error",e),r.toString()}return`${a}/login`},Q=(e,t)=>e&&t?`${a}/import/events/${e}/workflow/run/history/${t}`:`${a}/import/events`,J=({namespace:e})=>`${a}/namespaces/${e}/batch-operations`,K=({namespace:e,jobId:t})=>`${a}/namespaces/${e}/batch-operations/${t}`;export{l as O,g as a,O as b,C as c,w as d,J as e,Q as f,N as g,x as h,q as i,H as j,T as k,E as l,z as m,A as n,_ as o,d as p,K as q,B as r,L as s,m as t,D as u,R as v,W as w,j as x};
